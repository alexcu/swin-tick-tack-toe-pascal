{! Tick Tack Toe }{! Written By Alex Cummaudo 2013-12-12 }program TickTackToe;{ Define the Blip Type }type    BlipType = (Blank, Naught, Cross);    GridType = record        size : Integer;        grid : Array [0..9, 0..9] of BlipType;    end;    GameData = record        board : GridType;        quit  : Boolean;        turn  : BlipType;        win   : Boolean;end;{ Basic Exponentional (equivalent to 10^x) }function Exponent(x : Integer) : Integer;var    i : Integer;    result : Integer;begin    result := 1;        if ((x < 0) or (x > 4)) then    begin        WriteLn('ERROR: Invalid or overexcessive exponent!');        Exponent := -1;        exit;    end;        for i := x downto 1 do    begin        result := result * 10;    end;            Exponent := result;        end;{ Prompt }function Prompt(promptText : String) : String;var    input : String;begin    Write('  >> ', promptText, ': ');    ReadLn(input);    Prompt := input;end;{ Alert }procedure Alert(alertText : String);begin    WriteLn('   > ', alertText);end;{ Converts singular char to it's numerical equivalent }function CharToInt(input : Char) : Integer;begin    CharToInt := -1;    case input of        '0': CharToInt := 0;        '1': CharToInt := 1;        '2': CharToInt := 2;        '3': CharToInt := 3;        '4': CharToInt := 4;        '5': CharToInt := 5;        '6': CharToInt := 6;        '7': CharToInt := 7;        '8': CharToInt := 8;        '9': CharToInt := 9;    end;end;{ Reads in any, positive, whole integer with prompt }function ReadInteger(promptStr : String) : Integer;var    strInput : String;  { Raw string input                  }    numDigit : Integer; { The length of input (or # digits) }    ithDigit : Integer; { The integer of the i'th digit     }    i , j    : Integer; { Iterators for for loop            }    iDigExp  : Integer; { The exponent of this digit        }    result   : Integer; { The actual result                 }begin    strInput := Prompt(promptStr);    numDigit := Length(strInput);    result   := 0;        if (numDigit > 4) then    begin        Alert('ERROR: ' + strInput + ' is too high to convert!');        ReadInteger := -1;        exit;    end;            { Go down from MSD to LSD (in char terms that means      we want to go from the start of the string to EOS) }    for i := 1 to numDigit do    begin        ithDigit := CharToInt(strInput[i]);                { Exponent means the total worth of the ith digit          subtracted from the total number of digits       }        iDigExp  := Exponent(numDigit-i);                { Unsuccessful char to int conversion }        { Unsuccessful exp  raise (too high)  }        if ((ithDigit = -1) or (iDigExp = -1)) then         begin            Alert('ERROR: Conversion to Integer failed!');            ReadInteger := -1;            exit;        end;                { Otherwise, a succesful conversion }        result := result + (ithDigit * iDigExp);    end;        ReadInteger := result;end;{ Sets up the game passed with given params }procedure SetupGame(var theGame : GameData);var    boardSize, row, col : Integer;begin    Alert('Starting a new game');        { Quit to false }    theGame.quit := false;        { Win to false }    theGame.win := false;        { Cross goes first }    theGame.turn := cross;        { Read in the board's new size }    repeat        boardSize := ReadInteger('Enter a board size between 2 and 10');    until ((boardSize > 2) and (boardSize < 10));    theGame.board.size := boardSize;        { Set up the blanks in each row/col }    for row := 0 to boardSize do        for col := 0 to boardSize do            theGame.board.grid[row][col] := blank;    end;{ Converts a specific blip to textual equivalent }function BlipToString(var blip : BlipType) : String;begin    case blip of        Blank  : BlipToString := '_';        Naught : BlipToString := 'o';        Cross  : BlipToString := 'x';     end;end;{ Draws the grid to the screen }procedure DrawGrid(var board : GridType);var    row, col : Integer;begin    Alert('Drawing the game board: ');    WriteLn('');        { COLS HEADERS }    Write('   ');    for col := 1 to board.size do    begin        Write(col,' ');    end;    WriteLn('');        { ROWS }    for row := 1 to board.size do    begin        { Each row starts with a new blank space }        Write(row, ' ');                { COL }        for col := 1 to board.size do        begin            { Draw the row's column's blip with a space }            Write(' ', BlipToString(board.grid[col][row]));        end;                { End of the line? Write new line. }        WriteLn(' ');    end;    { End of the board? Write new line. }    WriteLn(' ');end;{ Draws the menu options }procedure DrawMenu(var game : GameData);begin    Alert('It''s ' + BlipToString(game.turn) + '''s turn');    Alert('[1] -> Enter Selection');    Alert('[2] -> New Game');    Alert('[0] -> Quit');    WriteLn('');end;{ Draws some simple separators around the board }procedure DrawSeparator(size : Integer);var    i : Integer;begin    WriteLn('');    WriteLn('');    for i:= 0 to size do        Write('=');    WriteLn('');    WriteLn('');end;{ Draws the grid as well as prompts for further stuff  to the screen }procedure DrawGame(var game : GameData);var    i : Integer;begin    DrawGrid(game.board);    DrawMenu(game);end;{ Swaps the current player to the opposite of whoever  is currently playing }procedure NextPlayer(var game : GameData);begin    if (game.turn = Naught) then        game.turn := Cross    else if (game.turn = Cross) then        game.turn := Naught;end;{ Prompts a confirm }function Confirm : Boolean;var    input : String;begin    Confirm := false;    input := Prompt('Are you sure? [y/n]');    if (input[1] = 'y') then    begin        Confirm := true;    end;end;{ Confirms the player's selection }function ConfirmSelection(col, row : Integer; var game : GameData) : Boolean;var    coords : String;begin    ConfirmSelection := false;        { Confirm that the col/row is in boundaries }    if (((col > game.board.size) or (row > game.board.size)) or        ((col < 1              ) or (row < 1                    ))) then        Alert('ALERT: The row or column is out of the range of the board!')        { The col/row is okay, but is anything there? }    else if (game.board.grid[col][row] <> blank) then    begin        Alert('ALERT: That position has been taken by ' + BlipToString(game.board.grid[col][row]));    end        { ELSE Everything is OKAY! }    else    begin        { Place the current turn (player) at that position) }        game.board.grid[col][row] := game.turn;        ConfirmSelection := true;    end;end;{ Checks a singular column that all match -- col static while row changes }function CheckCol(var board : GridType; col : Integer) : Boolean;var    row : Integer;begin    { Given the first blip isn't blank }    if (board.grid[col][1] <> blank) then    begin        { Start iterating through each row in this col          up until the second last row }        for row := 1 to (board.size-1) do        begin            { This blip doesn't match the blip underneath it }            if (board.grid[col][row] <> board.grid[col][row+1]) then            begin                CheckCol := false;                exit;            end;        end;        { Out of loop---must have passed! }        CheckCol := true;        exit;    end    { Otherwise, this is a blank blip }    else    begin        CheckCol := false;        exit;    end;end;{ Checks all cols for any match }function CheckAllCols(var board : GridType) : Boolean;var    col : Integer;    valid : Boolean;begin    CheckAllCols := false;        { Check every single col for row match }    for col := 1 to board.size do    begin        valid := CheckCol(board, col);        if (valid) then        begin            CheckAllCols := true;            exit;        end;    end;end;{ Checks a singular row that all match -- row static while col changes }function CheckRow(var board : GridType; row : Integer) : Boolean;var    col : Integer;begin        { Given the first blip isn't blank }    if (board.grid[1][row] <> blank) then    begin        { Start iterating through each column in this row          up until the second last column }        for col := 1 to (board.size-1) do        begin            { This blip doesn't match the blip next to it }            if (board.grid[col][row] <> board.grid[col+1][row]) then            begin                CheckRow := false;                exit;            end;        end;        { Out of loop---must have passed! }        CheckRow := true;        exit;    end    { Otherwise, this is a blank blip }    else    begin        CheckRow := false;        exit;    end;end;{ Checks all rows for any match }function CheckAllRows(var board : GridType) : Boolean;var    row : Integer;    valid : Boolean;begin    CheckAllRows := false;        { Check every single row for column match }    for row := 1 to board.size do    begin        valid := CheckRow(board, row);        if (valid) then        begin            CheckAllRows := true;            exit;        end;    end;end;{ Checks diagonals top left to bottom right }function CheckDiagTopBottom(var board : GridType) : Boolean;var    i : Integer;begin        { Given the first left top isn't blank }    if (board.grid[1][1] <> blank) then    begin        { Start iterating through every diag tile          up until the second last col/row }        for i := 1 to (board.size-1) do        begin            { This blip doesn't match the blip south-east to it }            if (board.grid[i][i] <> board.grid[i+1][i+1]) then            begin                CheckDiagTopBottom := false;                exit;            end;        end;        { Out of loop---must have passed! }        CheckDiagTopBottom := true;        exit;    end    { Otherwise, this is a blank blip }    else    begin        CheckDiagTopBottom := false;        exit;    end;end;{ Checks diagonals bottom left to top right }function CheckDiagBottomUp(var board : GridType) : Boolean;var    i : Integer;begin        { Given the bottom left top isn't blank }    if (board.grid[1][board.size] <> blank) then    begin        { Start iterating through every diag tile          down back up until second last col/row }        for i := board.size downto 2 do        begin                        { This blip doesn't match the blip north-east to it }            { board.size - i + 1 == say 6 - 6 + 1 = 1st col                                        6 - 5 + 1 = 2nd col                                        6 - 4 + 1 = 3rd col etc. }            if (board.grid[board.size-i+1][i] <> board.grid[board.size-i+2][i-1]) then            begin                CheckDiagBottomUp := false;                exit;            end;        end;        { Out of loop---must have passed! }        CheckDiagBottomUp := true;        exit;    end    { Otherwise, this is a blank blip }    else    begin        CheckDiagBottomUp := false;        exit;    end;end;{ Checks if a winner has won }procedure CheckWinner(var game : GameData);begin    if (CheckAllRows(game.board) or         CheckAllCols(game.board) or        CheckDiagTopBottom(game.board) or        CheckDiagBottomUp (game.board)) then    begin        game.win := true;        Alert('We have a winner: '+BlipToString(game.turn))    end    else        Alert('No winner yet');end;    { Prompts the user to enter in a selection }procedure EnterSelection(var game : GameData);var    colSelection : Integer;    rowSelection : Integer;begin    colSelection := ReadInteger('Enter column number');    rowSelection := ReadInteger('Enter row number');        { If confirmed selection }    if (ConfirmSelection(colSelection, rowSelection, game)) then    begin        { Check for winner }        CheckWinner(game);        { Move onto next player! }        NextPlayer(game);    end;end;procedure RecieveInput(var game : GameData);var    input : Integer;begin    input := ReadInteger('[?] ->');    case input of        0: game.quit := Confirm;        1: EnterSelection(game);        2:         begin            if (Confirm) then            begin                DrawSeparator(60);                SetupGame(game);            end;        end;                111:         begin             Alert('Force swap player');            NextPlayer(game);            DrawMenu(game);         end;    end;end;procedure Main;var    game : GameData;begin        WriteLn('    -- TICK TACK TOE v1.0 -- ');    WriteLn('    Written By Alex Cummaudo ');    WriteLn('');    SetupGame(game);        while not (game.quit) do    begin        DrawGame(game);        RecieveInput(game);        if (game.win) then        begin            DrawGrid(game.board);            DrawSeparator(60);            SetupGame(game);        end;    end;        Alert('Goodbye!');end;beginMain;end.